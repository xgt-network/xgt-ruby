#!/usr/bin/env ruby

require 'logger'
require 'bundler/setup'
require 'xgt/ruby'

# ------
# Config
# ------

# TODO: Validate
@host = ENV['HOST'] || 'http://localhost:8751'
# @host = ENV['HOST'] || 'http://demo-superproducers-lb-204476872.us-east-1.elb.amazonaws.com:8751'
@current_name = ENV['XGT_NAME'] || 'initminer'
@wifs = ENV['XGT_WIFS']&.split(';')&.map { |pair| pair.split(':').map { |n| n.split(',') } }&.to_h \
  || { 'initminer' => ['5JNHfZYKGaomSFvd4NUdQ9qMcEAC43kujbfjueTHpVapX1Kzq2n'] }
@logger = Logger.new($stdout)
@last_result = nil
@last_output = StringIO.new

# -------
# Helpers
# -------

def current_name
  @current_name
end

def current_wifs
  @wifs[current_name] || []
end

def logger
  @logger
end

def last_result
  @last_result
end

def last_output
  @last_output
end

COLORS = {
  yellow: 33,
  magenta: 35,
  cyan: 36,
}

def colorize(color, msg)
  %(\033[#{COLORS[color]}m#{msg}\033[0m)
end

def logo
  [
    colorize(:magenta, '           _'), "\n",
    colorize(:magenta, '__  ____ _| |_ '), colorize(:yellow, '              _ _     _'), "\n",
    colorize(:magenta, '\ \/ / _` | __|'), colorize(:yellow, ' __ __ ____ _| | |___| |_'), "\n",
    colorize(:magenta, ' >  < (_| | |_ '), colorize(:yellow, ' \ V  V / _` | | / -_)  _|'), "\n",
    colorize(:magenta, '/_/\_\__, |\__|'), colorize(:yellow, '  \_/\_/\__,_|_|_\___|\__|'), "\n",
    colorize(:magenta, '     |___/'), "\n",
    "\n",
    %(Type in "info" and hit enter for a list of commands.), "\n",
    "\n",
  ].join('')
end

def output_pair(key, value, indent_level)
  @last_output << %( ) * (4 * indent_level)
  @last_output << key if key
  @last_output << %( #{value}) if value
  @last_output << %(\n)
  $stdout << %( ) * (4 * indent_level)
  $stdout << colorize(:cyan, key) if key
  $stdout << %( #{value}) if value
  $stdout << %(\n)
end

def output_item(key, value, indent_level)
  if value.respond_to?(:keys) || value.respond_to?(:each)
    output_pair(key, nil, indent_level)
    output_subresult(value, indent_level + 1)
  else
    output_pair(key, value, indent_level)
  end
end

def output_subresult(item, indent_level=0)
  if item.respond_to?(:keys)
    item.each do |(key, value)|
      output_item(key, value, indent_level)
    end
  elsif item.respond_to?(:each)
    item.each.with_index do |value, i|
      output_item(i, value, indent_level)
    end
  else
    output_item(nil, value, indent_level)
  end
end

def output_result(item)
  @last_output = StringIO.new
  output_subresult(item)
  @last_output.rewind
  nil
end

def rpc
  Xgt::Ruby::Rpc.new(@host)
end

def chain_properties
  return @chain_properties if @chain_properties
  @chain_properties = rpc.call('condenser_api.get_chain_properties', [])
  @chain_properties
end

def config
  return @config if @config
  @config = rpc.call('condenser_api.get_config', [])
  @config
end

def address_prefix
  return @address_prefix if @address_prefix
  @address_prefix = config['STEEM_ADDRESS_PREFIX']
  logger.info(%(Retrieved address prefix... #{@address_prefix}))
  @address_prefix
end

def chain_id
  return @chain_id if @chain_id
  @chain_id = config['STEEM_CHAIN_ID']
  logger.info(%(Retrieved chain ID... #{@chain_id}))
  @chain_id
end

def fee
  return @fee if @fee
  @fee = chain_properties['account_creation_fee']
  logger.info(%(Retrieved account creation fee... #{@fee}))
  @fee
end

def currency_symbol
  return @currency_symbol if @currency_symbol
  @currency_symbol = fee.split(/\s+/).last
  logger.info(%(Retrieved currency symbol... #{@currency_symbol}))
  @currency_symbol
end

# --------
# Commands
# --------

def info
  print(%(\n))
  puts(colorize(:yellow, %(-----)))
  puts(colorize(:yellow, %(USAGE)))
  puts(colorize(:yellow, %(-----)))
  print(%(\n))
  puts(%(#{colorize(:cyan, 'info')} view this info message))
  puts(%(#{colorize(:cyan, 'switch_wallet NAME')} switch to another wallet))
  puts(%(#{colorize(:cyan, 'create_account')} create a new XGT wallet))
  puts(%(#{colorize(:cyan, 'list_accounts')} stream a full list of accounts))
  puts(%(#{colorize(:cyan, 'list_accounts NAME')} stream a full list of accounts, starting with NAME))
  puts(%(#{colorize(:cyan, 'get_account')} look up your wallet info))
  puts(%(#{colorize(:cyan, 'get_account NAME')} look up another user's wallet info))
  puts(%(#{colorize(:cyan, 'get_resource_params')} look up your rc info))
  puts(%(#{colorize(:cyan, 'get_resource_params NAME')} look up another user's rc info))
  puts(%(#{colorize(:cyan, 'transfer TO, AMOUNT')} transfer money to another wallet))
  puts(%(#{colorize(:cyan, 'transfer TO, AMOUNT, memo: "..."')} transfer money to another wallet))
  puts(%(#{colorize(:cyan, 'delegate_vesting TO, AMOUNT')} delegate VESTS to another wallet))
  print(%(\n))
  puts(colorize(:yellow, %(---------------------)))
  puts(colorize(:yellow, %(ENVIRONMENT VARIABLES)))
  puts(colorize(:yellow, %(---------------------)))
  print(%(\n))
  puts(%(#{colorize(:cyan, 'XGT_HOST')} a hostname of a valid superproducer))
  puts(%(#{colorize(:cyan, 'XGT_NAME')} the account name to use by default))
  puts(%(#{colorize(:cyan, 'XGT_WIFS')} mapping of names to WIFs, like `foo:123,234;bar:345`))
  print(%(\n))
  true
end

def switch_wallet(name)
  @current_name = name
end

def create_account
  creator_wif = Xgt::Ruby::Auth.generate_wif(current_name, current_wifs.first, 'active')
  master = Xgt::Ruby::Auth.random_wif
  owner_private = Xgt::Ruby::Auth.generate_wif(current_name, master, 'owner')
  owner_public = Xgt::Ruby::Auth.wif_to_public_key(owner_private, address_prefix)
  active_private = Xgt::Ruby::Auth.generate_wif(current_name, master, 'active')
  active_public = Xgt::Ruby::Auth.wif_to_public_key(active_private, address_prefix)
  posting_private = Xgt::Ruby::Auth.generate_wif(current_name, master, 'posting')
  posting_public = Xgt::Ruby::Auth.wif_to_public_key(posting_private, address_prefix)
  memo_private = Xgt::Ruby::Auth.generate_wif(current_name, master, 'memo')
  memo_public = Xgt::Ruby::Auth.wif_to_public_key(memo_private, address_prefix)

  txn = {
    'extensions' => [],
    'operations' => [[
      'account_create',
      {
        'fee' => fee,
        'creator' => current_name,
        'owner' => {
          'weight_threshold' => 1,
          'account_auths' => [],
          'key_auths' => [[owner_public, 1]]
        },
        'active' => {
          'weight_threshold' => 1,
          'account_auths' => [],
          'key_auths' => [[active_public, 1]]
        },
        'posting' => {
          'weight_threshold' => 1,
          'account_auths' => [],
          'key_auths' => [[posting_public, 1]]
        },
        'memo_key' => memo_public,
        'json_metadata' => '',
        'extensions' => []
      }
    ]]
  }

  signed = Xgt::Ruby::Auth.sign_transaction(rpc, txn, current_wifs, chain_id)
  response = rpc.call('call', ['condenser_api', 'broadcast_transaction_synchronous', [signed]])
  account_names = rpc.call('condenser_api.get_account_names_by_block_num', [response['block_num']])
  account_name = account_names.first

  # TODO: Get name from result instead
  response = {
    name: account_name,
    master: master,
    owner_private: owner_private,
    owner_public: owner_public,
    active_private: active_private,
    active_public: active_public,
    posting_private: posting_private,
    posting_public: posting_public,
    memo_private: memo_private,
    memo_public: memo_public
  }

  output_result(response)
  @last_result = response
  true
end

def list_accounts(name=nil)
  enumerator = Enumerator.new do |yielder|
    last_name = name
    loop do
      subresponse = rpc.call('database_api.list_accounts', {
        'start' => last_name,
        'limit' => 2,
        'order' => 'by_name'
      })
      accounts = subresponse['accounts']
      break if accounts.last['name'] == last_name
      accounts.each do |account|
        next if account['name'] == last_name
        yielder.yield(account)
      end
      last_name = accounts.last['name']
    end
  end
  response = { 'accounts' => enumerator }
  output_result(response)
  @last_result = response
  true
end

def get_account(name=current_name)
  response = rpc.call('database_api.find_accounts', { 'accounts' => [name] })
  output_result(response)
  @last_result = response
  true
end

def get_resource_params(name=current_name)
  response = rpc.call('rc_api.find_rc_accounts', { 'accounts' => [name] })
  output_result(response)
  @last_result = response
  true
end

def transfer(to, amount, memo: nil)
  string_amount = '%.3f' % (amount * 0.001)
  txn = {
    'extensions' => [],
    'operations' => [[
      'transfer',
      {
        'from' => current_name,
        'to' => to,
        'amount' => %(#{string_amount} #{currency_symbol}),
        'memo' => memo,
        'json_metadata' => '',
        'extensions' => []
      }
    ]]
  }

  logger.info(%(Allocating #{string_amount} #{currency_symbol} to "#{to}"))
  signed = Xgt::Ruby::Auth.sign_transaction(rpc, txn, current_wifs, chain_id)
  response = rpc.call('call', ['condenser_api', 'broadcast_transaction_synchronous', [signed]])
  output_result(response)
  @last_result = response
  true
end

def delegate_vesting(name, amount)
  vesting_shares = "#{'%.6f' % amount.to_i}"
  txn = {
    'extensions' => [],
    'operations' => [[
      'delegate_vesting_shares',
      {
        'delegator' => current_name,
        'delegatee' => name,
        'vesting_shares' => "#{vesting_shares} VESTS"
      }
    ]]
  }

  logger.info(%(Delegating #{vesting_shares} VESTS to "#{name}"))
  signed = Xgt::Ruby::Auth.sign_transaction(rpc, txn, current_wifs, chain_id)
  response = rpc.call('call', ['condenser_api', 'broadcast_transaction_synchronous', [signed]])
  output_result(response)
  @last_result = response
  true
end

# ----
# Main
# ----

# Allows for this file to be run as a script or loaded as a library.
if __FILE__ == $0
  puts logo

  require 'irb'
  IRB.start(__FILE__)
end
